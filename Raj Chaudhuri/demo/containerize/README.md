# PUG DevCon 2024 Demo - Containerize

This application shows several considerations for building an ASP.NET application for running in a container. It was built using the .NET SDK version 9 and Docker Desktop, and uses features provided by each. For example, it uses ASP.NET Core Identity for login, Entity Framework Core migrations for the database structure, and the Dockerfile was generated by the `docker init` feature of Docker Desktop.

## Source Code considerations

In [ET.Web/Program.cs](ET.Web/Program.cs), you can find:

* On lines 12-15, SQLite database configuration with a dedicated path for the database file.
* The use of the ASP.NET core default logger, which logs to standard output.
* On lines 40-45 and 95-98, a health check.
* On lines 54-78, application performing init activity itself, and failing fast if requirements are not met.

## Dockerfile considerations

The Dockerfile at [ET.Web/Dockerfile](ET.Web/Dockerfile) was generated using `docker init` and follows a number of Microsoft/Docker best pratices at the outset. Some more were added. 

* The Dockerfile is multi-stage and multi-architecture.
* The first stage, which builds the application from source, uses `mcr.microsoft.com/dotnet/sdk:9.0-alpine` as the base. This includes compilers and tools, which are not required once the application has been compiled.
* Lines 18-19 use the `dotnet publish` command to build the app (restoring any nuget packages as required) and publish the results to a directory called `/app` in the first stage.
* Line 27 runs the `dotnet tool restore` command, which pulls nuget packages that are used only during development/deployment. In this case, it restores `dotnet-aspnet-codegenerator` and `dotnet-ef` , which are mentioned in the file [.config/dotnet-tools.json](.config/dotnet-tools.json). That file was created using the `dotnet new tool-manifest` command during development, and the tools added to it using the `dotnet tool install --add-source` command. Doing this is a best practice, as we may need to run some these tools during image building, like we do here.
* Lines 28-29 create a subdirectory called `appdata` and use the `dotnet ef database update` command to create an initial SQLite database in it. This is what we needed to restore the `dotnet-ef` tool for.
* Lines 30-32 create a subdirectory under `/app` called `/app/appdata`, copy the SQLite database to it, and change the ownership of the file to a non-root user. The environment variable $APP_UID is defined in both Microsoft base images to be the id of a non-root user. Ideally, the application should run as that user. The ownership changes to the SQLite database file ensure that the application can read and write to it while running as that user.
* The second stage, which produces the final image, uses `mcr.microsoft.com/dotnet/aspnet:9.0-alpine` as the base image, and the result of the build gets copied to it. The final image, therefore, contains only what is needed to run the application.
* Line 39 copies _only_ the `/app` directory (recursively) from the first stage. This includes the database file with its changed ownership.
* Line 44 ensures that the application will run as a non-root user, whose identity is defined in the environment variable $APP_UID. This variable, as mentioned before, comes from the base image and matches the one defined in the first stage's base image.
* Line 46 provides the command line used to create the primary process of the application.
* Line 50 advertises the fact that the data of the application resides in a directory called `/app/appdata` in the container. Ideally, a volume should be mounted there. Docker will mount one by default if one is not specified. In Kubernetes, it has to be specified.

